### **발생 가능한 동시성 이슈**

1. 잔액 충전 및 차감 동시성 이슈
- 다수의 사용자가 동시에 잔액을 충전하거나 차감하면, 잔액이 올바르게 반영되지 않거나 예상치 못한 금액이 차감될 가능성이 있음.
- 예시)
    - 사용자 A와 B가 동시에 5,000원을 차감 요청
    - 원래 잔액: 10,000원
    - 동시에 요청이 들어오면, A와 B가 각각 잔액 확인 후 차감하면 결과적으로 5,000원만 차감될 수도 있음 (잔액이 -5,000원 되는 오류)

=> `Pessimistic Lock`을 적용하여 잔액 차감 시 동시에 같은 사용자의 잔액을 업데이트하지 못하도록 락을 걸어 해결

2. 쿠폰 동시 발급 이슈
- 다수의 사용자가 동시에 동일한 쿠폰을 발급받으면 초과 발급이 발생할 가능성이 있음.
- 예시)
    - 남은 쿠폰 수량: 100개
    - 200명의 사용자가 동시에 요청하면, 여러 스레드가 같은 quantity 값을 읽고 각각 1씩 차감하면 200장이 발급될 수도 있음

=> `Pessimistic Lock`을 적용하여 쿠폰이 중복 발급되지 않도록 트랜잭션 단위에서 락을 걸어 해결, 쿠폰 개수를 감소하는 로직을 트랜잭션 내에서 실행하여 초과 발급 방지
  
3. 결제 동시 처리 이슈
- 하나의 주문에 대해 중복 결제가 발생할 가능성이 있음.
- 예시)
    - 사용자가 한 주문을 결제할 때, 두 개의 결제 요청이 동시에 발생하면 두 번 결제될 가능성이 있음.

=> Pessimistic Lock을 함께 사용하여 동시에 여러 요청이 들어와도 첫 번째 요청만 처리되도록 설정

---

### **※동시성 제어 방법별 속도 비교 (예상 결과)**

| 방법 | 예상 실행 시간 | 설명 |
| --- | --- | --- |
| **아무 제어 없음 (Race Condition 발생 가능)** | 빠름 (하지만 오류 가능) | 동시 요청을 바로 처리하지만 데이터가 꼬일 가능성이 높음 |
| **Synchronized 사용** | 느림 | 하나씩 순차적으로 처리하므로 속도가 느려짐 |
| **Pessimistic Lock (비관적 락)** | 더 느림 | DB에서 락을 걸어 다른 요청이 끝날 때까지 대기 |
| **Optimistic Lock (낙관적 락)** | 빠름 | 충돌이 적으면 빠르고, 충돌이 많으면 다시 시도해야 해서 속도가 느려질 수도 있음 |
| **Redis 분산 락 사용** | 매우 빠름 | 데이터베이스가 아니라 Redis를 사용해 락을 걸면 빠름 |

---
**추가 개선 할 것**

- `Optimistic Lock`을 적용하여 성능 개선 가능 (ex: 재시도 로직 추가)
- `Redis 분산 락`을 도입하여 **확장성이 높은 방식으로 개선 가능**
- 추가적인 **부하 테스트(Load Test)**  필요

이번 테스트를 통해 **동시성 이슈를 체계적으로 분석하고 최적의 해결책을 도입**하여 문제를 방지하는 방법을 배웠습니다.
앞으로도 **다양한 동시성 제어 기법을 활용하여 더욱 효율적인 시스템을 설계할 필요가 있습니다.**